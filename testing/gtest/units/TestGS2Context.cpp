#include <gtest/gtest.h>
#include "../fixtures/GS2ContextFixture.h"
#include "encoding/graalencoding.h"

const char *validBasicScript = R"(
        function onCreated() {
          message("test onCreated");
        }
	)";

TEST(GS2Context, TestDefaultConstructor) {

	GS2Context gs2Context;
	auto result = gs2Context.compile("invalid code");

	EXPECT_EQ(result.success, false);
	EXPECT_EQ(1, result.errors.size());
	EXPECT_EQ("malformed input at line 1: invalid code", result.errors[0].msg());
}

TEST_F(GS2ContextFixture, TestCompileScript) {

	auto result = compile(validBasicScript);

	EXPECT_EQ(true, result.success);
	EXPECT_TRUE(result.errors.empty());
	EXPECT_EQ(0, result.errors.size());
}

TEST_F(GS2ContextFixture, TestCompileBadScript) {

	auto result = compile("bad script");

	EXPECT_EQ(result.success, false);
	EXPECT_EQ(1, result.errors.size());
	EXPECT_EQ("malformed input at line 1: bad script", result.errors[0].msg());

	result = compile("break;");
	EXPECT_EQ(result.success, true);
	EXPECT_EQ(1, result.errors.size());
	EXPECT_EQ("`break` outside loop detected", result.errors[0].msg());
}

TEST_F(GS2ContextFixture, TestJoinParsing) {
	auto res = compile(R"(join("test"); function onCreated() { this.join("anotherscript"); })");
	auto errorCount = printScriptErrors(res);

	EXPECT_EQ(0, errorCount);
	EXPECT_EQ(2, res.joinedClasses.size());
	EXPECT_TRUE(res.joinedClasses.contains("test"));
	EXPECT_TRUE(res.joinedClasses.contains("anotherscript"));
}

TEST_F(GS2ContextFixture, TestCompileHeaderEmptyBytecode) {

	auto res = context.CreateHeader({}, "weapon", "weaponName", true);

	EXPECT_EQ(0, res.length());
	EXPECT_EQ(nullptr, res.buffer());
}

TEST_F(GS2ContextFixture, TestCompileHeaderValidBytecode) {

	auto someScript = compile(validBasicScript);
	auto res = context.CreateHeader(someScript.bytecode, "weapon", "weaponName", true);

	ASSERT_NE(0, someScript.bytecode.length());
	ASSERT_NE(nullptr, someScript.bytecode.buffer());

	// Validate buffer headers
	auto length = res.Read<GraalShort>(0);
	ASSERT_EQ(strlen("weapon") + strlen("weaponName") + 4 + 10, length);

	char dst[1024];
	res.read(dst, length - 10, 2); // last 10 is randomly generated bytes
	dst[length - 10] = 0;
	ASSERT_EQ("weapon,weaponName,1,", std::string(dst));

	// Validate bytecode buffers
	res.read(dst, someScript.bytecode.length(), length + 2);
	ASSERT_TRUE(std::memcmp(someScript.bytecode.buffer(), dst, someScript.bytecode.length()) == 0);
}
