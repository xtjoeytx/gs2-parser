//#CLIENTSIDE
function onCreated()
{
  this.disabled = {"gx_events-teleport.nw", "g_event-koth.nw"};

  onTimeout();
}

function onActionClientSide(action)
{
  switch (action)
  {
    case "lightchg":
    {
      if (level.customlights == true)
      {
        level.effect = params[1];
      }
        
      break;
    }
  }
}

function onTimeout()
{
  // Run a function or two
  temp.time = player.getGraalTime(timevar % 1440);
  
  onUpdateDN(temp.time[3]);
  
  if (player.level.index(this.disabled) <= -1)
  {
    // Show Main GUI
    showimg(200, "gx_gui-new.png", 0, 0);
    changeimgvis(200, 4);
  
    // Others
    showtext(201, 34, 9, "Arial", "b", clientr.health[0] @ " / " @ clientr.health[1]);
    changeimgvis(201, 5);
    changeimgzoom(201, 0.6);
    showtext(202, 38, 26, "Arial", "b", clientr.health[3] @ " / " @ clientr.health[4]);
    changeimgvis(202, 5);
    changeimgzoom(202, 0.6);
    showtext(203, 34, 43, "Arial", "b", int(client.playermoney));
    changeimgvis(203, 5);
    changeimgzoom(203, 0.6);
  
    if (client.ammomax != "")
    {
      showtext(204, 38, 63, "Arial", "b", client.ammo @ " / " @ client.ammomax);
    }
      else
    {
      showtext(204, 38, 63, "Arial", "b", client.ammo);
    }
  
    changeimgvis(204, 5);
    changeimgzoom(204, 0.6);
    showtext(205, 101, 23, "Arial", "b", temp.time[1] @ ":" @ temp.time[0] @ " " @ temp.time[2]);
    changeimgvis(205, 5);
    changeimgzoom(205, 0.6);
  
    if (client.nopk == true)
    {
      showtext(206, 93, 43, "Arial", "b", "No-PK Zone");
      changeimgcolors(206, 0, 1, 0, 1);
    }
      else
    {
      showtext(206, 101, 43, "Arial", "b", "PK Zone");
      changeimgcolors(206, 1, 0, 0, 1);
    }
  
    changeimgvis(206, 5);
    changeimgzoom(206, 0.6);
    showtext(207, 124, 71, "Arial", "bc", "Food: " @ int(client.player_food[0]));
    changeimgvis(207, 5);
    changeimgzoom(207, 0.6);
  
    if (player.account == "KuJi")
    {
      showtext(208, 1, 90, "Arial", "b", "Tile: " @ tiles[mousex, mousey]);
      changeimgvis(208, 5);
      changeimgzoom(208, 0.6);
    }
      else
    {
      hideimg(208);
    }
  }
    else
  {
    hideimgs(200, 210);
  }
  
  // Timeout
  setTimer(0.05);
}

function onUpdateDN(temp.effect)
{
  if (client.flashed > 0) return false;
  
  if (player.account == "KuJi")
  {
    if (findimg(255).layer != 4)
    {
    //  checkRain();
    }
  }
  
  if (player.level.starts("gx_city1-"))
  {
    if (checkLightning() == true)
    {
      seteffect(0.4, 0.4, random(0.4, 0.55), random(0.5, 0.75));
    
      play("thunder.wav");
    }
      elseif (serverr.activity in |1, 5|)
    {
      seteffect(0, 0, 0, serverr.neffect);
    }
      else
    {
      seteffect(0, 0, 0, temp.effect);
    }
  }
    elseif (player.level.starts("g_mines"))
  {
    seteffect(0, 0, 0, 0.6);
  }
    elseif (player.level.starts("gx_airplane"))
  {
    seteffect(0, 0, 0, random(0.15, 0.2));
  }
    else
  {
    if (level.customlights == false)
    {
      seteffect(0, 0, 0, 0);
    }
      else
    {
      seteffect(level.effect[0], level.effect[1], level.effect[2], level.effect[3]);
    }
  }
  
  return true;
}

function checkLightning()
{
  if (serverr.activity == 3 || serverr.activity == 3)
  {
    if (random(0, 1) >= serverr.thunder[0] && random(0, 1) >= serverr.thunder[1])
    {
      return true;
    }
  }
  
  return false;
}

function checkRain()
{
  if (random(0, 1) > 0.6)
  {
    triggeraction(random(player.x - 32, player.x + 32), random(player.y - 32, player.y + 32), "water", "Rain");
  }
  
  with (findimg(255))
  {
    playlooped("gx_rainloop.wav");
    
    x = screenwidth;
    y = 50;
    alpha = 0;
    layer = 4;
    this.shootAngle2 = pi * 1.5;
    this.shootAngle = this.shootAngle2 + this.angle;
    emitter.autorotation = false;
    emitter.attachposition = false; // If the image's x and y move, would the entire emitter, every single particle at once, move along with the image? If true, every sprite moves when the image movies. If false, then only the point of origin, where the particles are created, move when the image is moved.
    emitter.delaymin = 0; // This is the minimum delay between emissions.
    emitter.delaymax = 0; // This is the maximum delay between emissions, both of these are in seconds.
    emitter.emissionoffset = {0, -40, 0}; // In format of "{float, float, float}", it's the offset from the x, y, and z that an emission will show. It's the delta variables for the location, basically.
    emitter.firstinfront = 1; // Should the first emitted particle be in front of every other particle?
    emitter.nrofparticles = 10; // The number of particles to be released at the same exact time when the emitter emits. For example, set this to two, and you'll have two particles released every time instead of the default 1.
    emitter.maxparticles = 80; // The maximum number of particles that can exist at one time. If this limit is reached, the script will wait until one of the particles runs out before emitting another one.
    emitter.particle.lifetime = 1; // How long, in seconds, the emitter lasts.
    emitter.particle.image = "gx_rain.png"; // The imagename of the emitter
    emitter.particle.mode = 0; // Either 0, 1, or 2, the same as changeimgmode. 0 = add, 1 = trans, 2 = subtract. Use this for a blacklight effect if you wish.
    emitter.particle.alpha = 0.3; // Between 0 and 1, the alpha colour for transparancy
    emitter.particle.zoom = 1; // The zoom effect of the particle
    emitter.particle.red = .6;
    emitter.particle.green = .6;
    emitter.particle.blue = 1; // These three are between 0 and 1, and they're the colours of the individual particles
    emitter.particle.zangle = 0; // Between 0 and pi*2, it's the upward angle of the particles. Remember zangle from the shoot() function? Same basic idea.
    emitter.particle.angle = this.shootAngle; // Again, between 0 and pi*2, it's the angle that the particle should flow.
    emitter.particle.speed = 1500; // I'm not sure if this is measured in Tiles per second or what, but it's the speed. Higher = faster, obviously
    emitter.particle.stretchx = 1; // This is how 'stretched' each particle will be, relative to width.
    emitter.particle.stretchy = 1; // This is how 'stretched' each particle will be, relative to height.
    emitter.addLocalModifier("once", 0, .1, "angle", "replace", pi*1.5, pi*1.5 + .3);
    emitter.addLocalModifier("once", 0, 0, "x", "replace", -600, screenwidth + 20);
  }
}

function onMouseDown(mtype)
{
  switch (mtype)
  {
    case "double":
    {
      this.tiles.add(tiles[mousex, mousey]);
      
      echo(this.tiles);
      
      break;
    }
    
    case "right":
    {
      this.tiles = "";
      
      echo("Tiles Cleared!");
      
      break;
    }
  }
}